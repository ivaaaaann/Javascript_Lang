# 데이터 타입

자바스크립트에서 데이터 타입은 **기본형**과 **참조형**으로 나뉜다.

<h3>기본형</h3>
기본형에는 number, string, boolean, null, undefined, symbol이 있다.
<h3>참조형</h3>
참조형에는 object(객체) 가 있고 이 하위에 array, Function, Date, RegExp, Map, WeakMap, Set, WeakSet이 있다.

# 데이터 불변성

기본형과 참조형은 어떤 기준으로 구분할까? 바로 불변값이냐 가변값이냐로 구분한다.<br>

일단 기본형은 불변값이고 불변성을 뛴다. 불변성에 대해 이해 할려면 메모리와 데이터에 대해 잘 알아야 한다.

먼저 컴퓨터는 모든 데이터들을 0,1 로 바꾸어 저장한다. 이 단위는 비트라고 한다. 이 비트들은 고유한 식별자를 통해서 메모리 위치를 확인한다. 하지만 위치를 확인 할 때 가장 작은 단위인 비트단위로 확인한다면 굉장히 느릴 것이다. 그래서 비트들을 적당한 크기로 묶었는데 이 단위가 바로 **바이트**이다. 바이트도 비트와 같이 시작하는 비트의 식별자로위치를 파악할 수 있다. 이를 바이트 단위의 식별자 즉 **메모리 주솟값**이라고 한다. 보통 이 식별자와 변수를 혼용하여 쓰는 경우가 많다. 이를 혼용하는 이유는 문맥에 따라 무엇을 말하고자 하는지 알 수 있기 때문인데 둘의 차이를 모른다면 혼란스러울 수 있다. 변수는 "변할수 있는 무언가" 즉 **데이터**를 말하고 식별자는 데이터를 식별하기 위해 사용하는 이름 즉 **변수명**이다. 그러면 이를 바탕으로 데이터를 할당하면

    var a;
    a = 'abc';

이런형식이 될 것이다. 흐름을 예상해보자면 빈공간에 a라는 이름의 식별자를 지정해주고 그 공간에 abc라는 문자열을 넣어줄 것이다. 하지만 실제로는 그게 아니다. a라는 공간이 생기고 또 메모리 공간을 확보해서 abc를 저장하고 그 주소를 a(변수영역)에 저장하는 식이다.

![변수영역](https://images.velog.io/images/haesoohaesoo/post/a50d89b4-d4f9-4f09-b8f9-665dc16c349a/image.png)

그러면 또 변수영역과 데이터 영역은 뭘까? 그리고 왜 변수 영역에 값을 직접 넣지 않고 번거롭게 한단계를 더 거치는 것일까? 이는 메모리를 효율적으로 관리하고 데이터를 자유롭게 변환시키기 위함이다. 예를 들어 문자열은 데이터 길이가 가변적이다. 그러면 어떤 공간에서 변한 데이터를 넣으면 공간을 그 데이터 크기에 맞게 늘리는 작업이 필요 할 것이다. 이런 상황 말고도 다른 상황이 많다. 결국 컴퓨터가 처리해야 할 연산이 많아질 수 밖에 없다. 그래서 변수영역과 데이터 영역을 나눈 것이다. 그러면 다시 본론으로 돌아와서, 데이터 영역에서 abc를 저장하고 이 주소를 변수영역에서 a식별자가 있는 공간에 넣어준다. 변수에 아무리 값을 할당해도 그 공간에 직접 할당하지 않고, 데이터 영역에서 데이터를 담고 그 주소를 넣어주기 때문에 변수는 변하지 않는다. 이 부분이 바로 기본형이 불변성을 뛰고 불변값인 이유다.

기본형은 알았으니 이제 참조형에 대해 알아보자.

참조형은 기본형과 반대되게 가변값이다. 하지만 설정에 따라 불변값이 되는 경우도 있다.

참조형과 기본형 데이터와의 차이점은 객체의 변수 영역이 따로 존재한다는 것이다.

![](https://velog.velcdn.com/images%2Fk904808%2Fpost%2Fde410f51-6382-4687-b8c1-a1c8400697f2%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-03-25%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201.10.44.png)

그림을 보면 객체가 할당한 영역은 변수 영역밖에 없고, 데이터 영역은 기존의 메모리 공간을 그대로 쓰고 있다. 그리고 데이터 영역에 저장된 값은 불변값이지만 변수영역은 얼마든지 값을 대입 할 수 있다. 바로 이 점때문에 참조형 데이터는 가변값이라고 할 수 있다. 위에 코드를 보면

    const obj1 = {
        a : 1,
        b : "bbb";
    }

의 형식인데, 여기서 obj.a = "aaa"; 를 해주면 aaa 값이 있는지 찾고 없으면 데이터 영역에 새로운 공간 5006 에 할당한다. 그리고 주소 7103 공간에는 값이 5006으로 바뀌게 된다. 그러면 5003은 더이상 자신의 주소를 참조하는 변수가 하나도 없게 된다. 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 **참조 카운트**라고 한다. 따라서 5003의 참조카운트는 0이다. 참조카운트가 0인 메모리 주소는 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때 가비지 컬렉터가 자동으로 수거한다. 수거된 메모리는 새로운 값을 할당 할 수 있는 빈 공간이 된다.

# undefined와 null

자바스크립트에서는 '없음'을 표현하는 값이 두가지가 있다. 바로 undefined와 null인데 둘이 언뜻 보면 비슷해 보일 수 있다. 하지만 둘은 미세한 차이가 분명하게 존재한다.

먼저 undefined은 부여되는 경우가 2가지있다. 사용자가 명시적으로 지정하는 방식과, 자바스크립트 엔진이 자동으로 부여하는 방식 이렇게 2가지가 있다. 사용자가 명시하는 방식은 간단하게 우리가 잘 아는 var a = undefined; 이런식이다. 그러면 자바스크립트 엔진이 자동으로 부여해주는 방식은 뭘까? 자바스크립트 엔진은 사용자가 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 부여해준다.

    var c;

    console.log(c);

    var obj3 = {
    a: 1,
    };

    console.log(obj3.a);
    console.log(obj3.b);
    console.log(b);

    var func = function () {};
    var d = func();
    console.log(d);

1. 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부에 존재하지 않는 프로퍼티에 접근할 때
3. return 문이 없거나 호출 되지 않은 함수의 실행 결과<br>

이 세가지 경우가 해당한다. 하지만 이렇게 자동으로 부여 해주는 방식에 대해 배열의 경우는 좀 특이하다. 

    var arr1 = [];
    arr1.length = 3;
    console.log(arr1);

    var arr2 = new Array(3);
    console.log(arr2);

    var arr3 = [undefined, undefined, undefined];
    console.log(arr3);

 첫번째 arr1은 크기를 3으로 하고 콘솔로 출력하니 empty가 3번 출력 됐다. 이는 배열에 3개의 빈공간을 확보했지만 아무 값도, 심지어 undefined도 할당 돼 있지 않음을 의미한다. arr2도 arr1과 비슷하게 배열 인스턴스를 생성해준후 크기를 3으로 지정했다. 그러고 콘솔로 출력하니 결과는 arr1과 같았다. 하지만 arr3은 위와 다르게 리터럴 방식으로 배열을 생성하면서 undefined를 부여했다. 그리고 콘솔로 출력하니 undefined가 3번 출력 됐다. 이처럼 '비어있는 요소(empty)'와 'undefined'는 출력결과부터 다르다. empty 요소는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외 된다. 사용자가 명시한 undefined의 경우 비록 '비어있음'을 의미하긴 하지만 하나의 값으로 동작하기 때문에 이때 고유의 키값은 존재하게 되고, 따라서 순회 대상이 된다. 하지만 사용자가 아무것도 하지 않은 채로 자바스크립트 엔진이 하는 수 없이 반환해주는 undefined는 키값 자체가 존재하지않음을 의미한다. 그래서 순회 대상에서 제외되는 것이다. 같은 undefined인데 다르다니 좀 많이 복잡하다. 하지만 단순하게 모든 undefined의 경우를 자바스크립트가 반환해주는 경우로 통일시켜주면 복잡할 필요가 없다. 그냥 우리가 undefined를 할당 해주지 않으면 된다. undefined 대신에 null을 사용하면 된다. null은 원래 그러라고 있는 데이터 타입이다.   
