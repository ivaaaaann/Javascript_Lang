# 함수

함수를 선언하는 방식은 다음과 같다.

- function 키워드 함수
- 생성기 함수
- 비동기 함수
- 화살표 함수

## function 키워드 함수

```
function func() {

}
```

다음과 같은 형식으로 선언한다. 다음과 같은 형식으로 선언한 방식은 '문'이기때문에 끝에 세미콜론이 필요없다. 하지만 이 함수를 값으로 변환시킬 수 있다.

```
(function () {

})

const func = (function(){});
```

다음과 같은 형식으로 값으로 바꿀 수 있다. 값으로 바꿔서 변수에 할당할 수도있다. 다음과 같이 값으로 바꾸게 되면 세미콜론이 필요하다.

### 함수 즉시 호출

```
(function() {})()
```

다음과 같이 값으로 변환하고 뒤에()로 바로 호출할 수 있다.

## 생성기 함수

```
function* func() {
    yield 1;
    yield 2;
    return 3;
}

func()
func().next()

```

생성기 함수는 function 키워드에 \*를 붙혀서 사용한다. 함수를 처음 호출하게 되면 코드 블럭 안에있는 코드들이 실행되지 않고 다음 동작을 하도록 준비상태가 된다. 준비상태에서 next()함수를 통해서 하나하나씩 진행된다. next를 할수록 yield에서 차례대로 함수에 값이 들어간다.

## 비동기 함수

```
async function func() {

}
```

복잡한 promise문법을 async await키워드를 통해 간단하게 구성할 수 있다.

## 화살표 함수

```
() => {}
```

다음과 같은 방식으로 선언할 수 있다. 그리고 이것도 function 함수와 같이 변수에 할당할 수 있다.

```
const func = () => {}
```

겉으로 봤을때 function 함수와 다를게 없어보이지만, => 앞에 코드블럭이 필요 없다.

```
function func(){
    return 100
}

const func = () => 100
```

다음과 같이 일반 function 함수는 {}코드블럭을 열고 return 100을 해줘야 100이 리턴되지만, 화살표 함수는 => 앞에 값을 적어서 return을 생략할 수 있다.

## 함수 호출 방식

함수는 보통 ()를 사용하여 호출한다.
하지만 이 방식 말고도 다른 방식이 있다

```
function func() {

}

func()
func.apply()
func.call
```

call과 apply이 2개가 더 있는데 저렇게 봤을때 일반적으로 ()호출과 별 차이가 없다. 그러면 왜 쓰는 것일까? 바로 매개변수를 넣는 방식에서 차이가 있다. 일단 그전에 먼저 매개변수가 가변적으로 오면 어떻게 되는지부터 알아보자.

```
function sum(a , b) {
    return a + b
}

sum(1,2)
```

다음과 같이 a,b를 매개변수로 받는 함수에 매개변수로 1,2를 넣었다. 그러면 당연히 결과는 둘이 합쳐진 3이 리턴될 것이다. 만약 매개변수로 1,2,3,4를 넣었다면 어떻게 될까? 함수는 a,b만 지정해놨기 때문에 뒤에 오는 3,4는 무시된다. 하지만 이렇게 지정해 놨다고 해도 만약 더 받았다면 유동적으로 처리해준다면 더 좋은 함수가 될것이다. 그래서 함수에서는 받은 매개변수를 무시하지 않고 arguments 라는 유사배열에 매개변수를 담아놓는다. 그래서 다음과 같이 이용할 수 있다.

```
function sum() {
    let sum = 0;

    for(let i = 0; i < arguments.length; i++) {
        sum += arguments[i]
    }

    return sum;
}
```

하지만 이는 sum함수를 닫은채로 봤을때 함수 시그니쳐가 명확하지 않는다. 그래서 자바스크립트는 전개연산자라는 것을 제공한다.

```
function sum(...args) {
    let sum = 0;

    for(let i = 0; i < args.length; i++) {
        sum += args[i]
    }

    return sum;
}
```

이렇게 사용하면 함수의 시그니쳐도 명확하게 표현 할 수 있다. 약간 내용이 산으로 갔는데 그래서 ()와 apply(), call()의 차이는 뭘까? 둘의 차이는 매개변수를 넣는 방식에서 차이가 있는데

```
sum.call(null,1,2,3,4,5)
sum.apply(null, [1,2,3,4,5])
```

다음과 같은 차이가 있다. 먼저 call, aplly 첫번째 매개변수로 컨텍스트가 들어간다.(일단 null로 해놓음) 그리고 뒤에 sum함수에서 받는 매개변수를 넣는다. call 함수는 매개변수를 하나하나 넣어준다. 그와 다르게 apply함수는 2번째 인자까지만 받고 배열로 값을 여러개를 받는다. 이점이 바로 call과 apply의 차이점이다. 하지만 call은 매개변수를 변경하려면 코드를 변경시켜야 하지만, apply는 배열로 받기 때문에 값을 변경시켜주면 된다. 이 부분에서 apply가 call보다 더 유리하다.
